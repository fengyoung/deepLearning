#define EIGEN_NO_DEBUG
#include <stdio.h>
#include <iostream>
#include <string>
#include <Eigen/Eigen>
#include <vector>
using namespace std;
using namespace Eigen;

MatrixXd sigm(MatrixXd x);
MatrixXd tanh(MatrixXd x);
VectorXd dropoutMask(int size, double fraction);
MatrixXd bernoulli_sample(MatrixXd prob);
MatrixXd extractCols(MatrixXd &x, VectorXd indices);
int updateCols(MatrixXd &x, MatrixXd &up, VectorXd indices);
ArrayXXi sign(ArrayXXd x);

class feedForwardNetwork;
class stackedAutoEncoder;

class RBM {
	public:
		Vector2i size; // input, hidden size
		MatrixXd W, delta_W;  // hidden x visible
		VectorXd vBias, delta_vBias; // visible bias
		VectorXd hBias, delta_hBias; // hidden bias

		RBM(int visible, int hidden);
		RBM(MatrixXd _W, MatrixXd _delta_W, 
			VectorXd _vBias, VectorXd _delta_vBias,
			VectorXd _hBias, VectorXd _delta_hBias, 
			Vector2i _size);
		RBM(RBM &rbm_trained);
		//
		MatrixXd prob_v_given_h(MatrixXd h);
		MatrixXd prob_h_given_v(MatrixXd v);
		MatrixXd sample_v_given_h(MatrixXd h);
		MatrixXd sample_h_given_v(MatrixXd v);
		double train_a_batch(MatrixXd v1, int s);

		VectorXd RBM::train(MatrixXd &x, int numepochs = 10, int batchsize = 50, double learning_rate = 0.1, 
			double momentum = 0.5, double learning_rate_scale = 1.0, int CD = 1);
	};


class DBN {
	public:
		VectorXi size;
		std::vector<RBM> rbm;
		string hidden_type, visible_type;

		DBN(int input_dim, VectorXi hid);
		//
		std::vector<VectorXd> train(MatrixXd &x, double learning_rate = 0.8, 
			double learning_rate_scale = 1, double momentum = 0.5, int numepochs = 3, 
			int batchsize = 100, int CD = 1, bool verbose = true);
		//
		//MatrixXd move_down(MatrixXd h, int round = 10);
		MatrixXd extractFeature(MatrixXd x);
		MatrixXd reconstruct(MatrixXd x);
	};



class feedForwardNetwork {
	private:
		std::vector<MatrixXd> post;
		std::vector<MatrixXd> dropout_mask;
		void errorBackPropFromOutput(MatrixXd & d);
		void errorBackProp(MatrixXd & d, int i);
	public:
		VectorXi layer_size;
		string act_fun;
		string output;
		double hidden_dropout; 
		double visible_dropout;
		std::vector<MatrixXd> W;
		std::vector<VectorXd> B;
		//copy constuctor: can be generated by system
		//feedForwardNetwork(feedForwardNetwork &nn);
		feedForwardNetwork(VectorXi size, string actf = "sigm", string out = "linear", double hid_dropout = 0.0, double vis_dropout = 0.0);
		feedForwardNetwork(stackedAutoEncoder &sae, int output_dim, string out = "linear", double hid_dropout = 0.0, double vis_dropout = 0.0);
		//
		MatrixXd ff(MatrixXd batch_x, MatrixXd batch_y);
		MatrixXd ff(MatrixXd batch_x);
		MatrixXd ff(MatrixXd batch_x, int nstep);
		//
		int bp(MatrixXd error, vector<MatrixXd> & dW, vector<VectorXd> & dB, double learning_rate = 0.05, double momentum = 0.5);
		VectorXd bpTrain(MatrixXd x, MatrixXd y, int numepochs = 10, int batchsize = 50, 
			double learning_rate = 0.05, double momentum = 0.5, double learning_rate_scale = 1.0, bool verbose = true);
		//
		int rprop(MatrixXd error, vector<MatrixXd> & dW, vector<VectorXd> & dB, vector<ArrayXXi> & signDeltaW, vector<ArrayXi> & signDeltaB, 
			double incScale = 1.2, double decScale = 0.5, double incScaleMax = 50.0, double decScaleMin = 1e-6);
		VectorXd rpropTrain(MatrixXd x, MatrixXd y, int numepochs = 10, int batchsize = 50, 
			double incScale = 1.2, double decScale = 0.5, double incScaleMax = 50.0, double decScaleMin = 1e-6, bool verbose = true);
		//
		int quickprop(MatrixXd error, vector<MatrixXd> & dW, vector<VectorXd> & dB, vector<MatrixXd> & gradW, vector<VectorXd> & gradB);
		VectorXd quickpropTrain(MatrixXd x, MatrixXd y, int numepochs = 10, int batchsize = 50, bool verbose = true);
		//
		MatrixXd predict(MatrixXd batch_x);
		MatrixXd predict(MatrixXd batch_x, int nstep, int start = 0);
	};


class stackedAutoEncoder{
	public: 
		int input_dim;
		VectorXi hidden;
		vector<feedForwardNetwork> layer;
		//
		stackedAutoEncoder(int in_dim, VectorXi hid, string act_fun = "sigm", string reconst_fun = "sigm", double hid_dropout = 0.0, double vis_dropout = 0.0);
		MatrixXd bpTrain(MatrixXd x, int numepochs = 10, int batchsize = 50, 
			double learning_rate = 0.05, double momentum = 0.5, double learning_rate_scale = 1.0, bool verbose = true);
		MatrixXd rpropTrain(MatrixXd x, int numepochs = 10, int batchsize = 50, 
			double incScale = 1.2, double decScale = 0.5, double incScaleMax = 50.0, double decScaleMin = 1e-6, bool verbose = true);
		MatrixXd extractFeature(MatrixXd x);
		MatrixXd reconstruct(MatrixXd x);
	};
